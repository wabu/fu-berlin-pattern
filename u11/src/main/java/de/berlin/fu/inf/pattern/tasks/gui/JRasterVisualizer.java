/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * JGreyRaster.java
 *
 * Created on 17.01.2010, 16:19:49
 */

package de.berlin.fu.inf.pattern.tasks.gui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import javax.swing.SwingUtilities;
import org.apache.log4j.Logger;

/**
 *
 * @author alex
 */
public class JRasterVisualizer extends javax.swing.JPanel {
    private final Logger logger = Logger.getLogger(JRasterVisualizer.class);

    public static final int DEFAULT_RASTERSCALE = 5;
    private static final Dimension ZERO_DIMENSION = new Dimension(10, 10);

    private RasterModel model;
    private ModelChangedListener modelListener;
    private int rasterScale;

    public JRasterVisualizer() {
        this(DEFAULT_RASTERSCALE);
    }

    /** Creates new form JGreyRaster */
    public JRasterVisualizer(int rasterScale) {
        initComponents();
        this.rasterScale = rasterScale;
        modelListener = new ModelChangedListener() {
            public void onModelChanged(ModelChangedEvent evt) {
                logger.trace("onModelChanged: " + evt);
                if( evt.getSource() == model ) {
                    updateView();
                }
            }
        };
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.LOWERED));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 394, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 294, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    @Override
    protected void paintComponent(Graphics grphcs) {
        super.paintComponent(grphcs);
        // TODO: synchronization?!
        if( model == null ) return;
        // draw the raster
        // draw an rect for any element of raster
        for( int x = 0; x<model.getCols(); x++) {
            for( int y = 0; y<model.getRows(); y++) {
                float greyScale = (float) model.getColor(x, y);
                if(greyScale >= 0 ) {
                    grphcs.setColor(new Color(greyScale, greyScale, greyScale));
                } else {
                    grphcs.setColor(new Color(-greyScale, 0, 0));
                }
                grphcs.fillRect(
                        rasterScale*x,      // x
                        rasterScale*y,      // y
                        rasterScale,        // width
                        rasterScale);       // height
            }
        }
    }


    public RasterModel getModel() {
        return model;
    }

    public void setModel(RasterModel model) {
        if( this.model != null ) {
            model.removeModelChangedListener(modelListener);
        }
        logger.debug("set model to " + model);
        this.model = model;
        this.model.addModelChangedListener(modelListener);

        // cause of new model
        this.updateView();
    }

    @Override
    public Dimension getMaximumSize() {
        return this.getPreferredSize();
    }

    @Override
    public Dimension getMinimumSize() {
        return this.getPreferredSize();
    }

    /**
     * the preffered size depends on dimension of raster and chosen raster scale
     * factor. it calculates: (rasterScale*rasterWidth, rasterScale*rasterHeight)
     *
     * @return
     */
    @Override
    public Dimension getPreferredSize() {
        if( this.model == null ) {
            logger.trace("return preferredSize: " + ZERO_DIMENSION);
            return ZERO_DIMENSION;
        }
        else {
            Dimension dim = new Dimension(
                    rasterScale*model.getCols(),
                    rasterScale*model.getRows());
            logger.trace("return preferredSize: " + dim);
            return dim;
        }
    }


    /**
     * This method does start repaint in separate thread. is invoked after changes
     * on model or view
     */
    protected void updateView() {
        logger.trace("update view");
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                // need to update layout before painting
                invalidate();
                getParent().validate();

                repaint();
            }
        });

    }



    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

}
